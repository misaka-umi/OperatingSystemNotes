# 进程与线程

## 进程与线程

### 进程的概念和特征

- 进程的概念
  
  - ```
    多道程序环境下，允许多程序并发执行，
    失去封闭性，并具有间断性和不可再现性。
    ```
  
  - 进程控制块PCB
    
    - 程序段
    
    - 相关数据段
    
    - PCB
    
    - ```
      创建进程实际上是创建进程实体的pcb
      进程映像是静态的，进程则是动态的
      ```

- 进程的特征
  
  - 动态性
    
    - 进程是程序的一次执行，有着创建、活动、暂停、终止等过程。
    
    - 是进程最基本的特征
  
  - 并发行
    
    - 是进程和操作系统的重要特征
  
  - 独立性
    
    - 能独立运行、独立获得资源、独立接受调度的基本单位
  
  - 异步性
    
    - 因此需要进程同步机制
  
  - ```
    进程特征不需要背诵
    ```

### 进程的状态与转换

- 运行态

- 就绪态

- 阻塞态

- 创建态

- 结束态

- 3种基本状态的转换：
  
  - 就绪态->运行态
    
    - ```
      就绪态被调度，获得处理机资源
      ```
  
  - 运行态->就绪态
    
    - ```
      处于运行态的进程在时间片用完后让出处理机
      或被更高优先级的进程抢占/剥夺
      ```
  
  - 运行态->阻塞态
    
    - ```
      请求资源
      ```
  
  - 阻塞态->就绪态
    
    - ```
      进程等待的事件到来。
      io操作结束或中断结束时，
      中断处理程序需要将相应进程的状态转为就绪态
      ```

### 进程的组织

- 进程控制块
  
  - 进程描述信息
    
    - ```进程标识符
      标志各个进程，唯一。
      ```
    
    - ```用户标识符
      进程归属的用户。用于共享和保护
      ```
  
  - 进程控制和管理信息
    
    - 进程当前状态
    
    - 进程优先级
  
  - 资源分配清单
    
    - 包括内存地址空间、虚拟地址空间，所打开列表的输入输出设备信息
  
  - 处理机相关信息
    
    - 处理器中寄存器的值

- 程序段
  
  - 能被*进程调度程序*调度到cpu执行的程序代码段

- 数据段
  
  - 进程对应的程序加工处理的原始数据/程序执行产生的中间/最终结果

### 进程控制

进程控制的程序段为**原语**

- 进程的创建
  
  - ```
    允许一个进程创建另一个进程
    前者父进程后者子进程
    子进程可以继承父进程的资源 被撤销时应当归还资源
    撤销父进程也会撤销所有子进程
    ```
  
  - 过程如下
    
    - 为新进程分配一个唯一的进程标示号，并创建空白pcb（有限）
    
    - 分配资源
    
    - 初始化pcb
    
    - 插入就绪队列（如允许）

- 进程的终止
  
  - 引起原因
    
    - 正常结束
    
    - 异常结束
      
      - 越界错误、保护错、特权指令错、io故障等
    
    - 外界干预
      
      - 操作员或操作系统干预
      
      - 父进程请求和父进程终止
  
  - 过程如下
    
    - 根据标识符检索出pcb，读出进程状态
    
    - 若处于执行状态则立刻终止
    
    - 若有子孙进程，将它们全部终止
    
    - 将所有资源归还给父进程/操作系统
    
    - 将pcb从所在队列（链表）中删除

- 进程的阻塞和唤醒
  
  - 阻塞原语block
    
    - 找到被阻塞进程的标示号对应的pcb
    
    - 若为运行态，保护现场；将其状态转为阻塞态，停止运行
    
    - 将pcb插入等待队列，将处理机资源让出
  
  - 唤醒原语wakeup
    
    - 在等待队列中找到相应进程的pcb
    
    - 将其从等待队列中移除，设为就绪态
    
    - 插入就绪队列

### 进程的通信

pv操作为低级通信方式

高级通信方法：

- 共享存储
  
  - ```
    对共享空间进行读写操作需要同步互斥工具（pv操作）
    共享存储分为两种：
        低级方式对共享基于数据结构的共享
        高级方式的共享基于存储区的共享
    ```

- 消息传递
  
  - ```
    以格式化的消息为单位
    ```
  
  - 直接通信方式
    
    - 直接把消息发给接收进程，并挂在接收进程的消息缓冲队列中
  
  - 间接通信方式
    
    - 发送进程->中间实体（一般为信箱）->接收进程

- 管道通信
  
  - 管道本质上是一种文件
  
  - 字符流的方式从发送进程送到（写）管道
  
  - 接收管道输出的接收进程从管道中接收数据
  
  - 存储空间进化为缓冲区
  
  - 半双工通信

### 线程和多线程模型

- 线程的基本概念
  
  - ```
    “轻量级进程”
    基本的cpu执行单位，程序执行流的最小单元
    是进程的一个实体，被系统独立调度和分派的基本单位
    没有自己的系统资源，同进程的多个线程可共享
    ```
  
  - 引入线程后，进程只作为除cpu外的系统资源的分配单元

- 线程与进程的比较
  
  - 调度
    
    - 同一进程的线程切换不会引起进程切换
    
    - 不同的进程的线程切换会引起
  
  - 并发性
    
    - 多进程并发、同一进程多线程并发、不同进程多线程并发
  
  - 拥有资源
    
    - 线程通过进程访问系统资源
    
    - 属于同一进程的所有线程都具有相同的地址空间
  
  - 独立性
    
    - 进程的线程对其他进程不可见
  
  - 系统开销
    
    - 撤销进程/撤销线程
  
  - 支持多处理机系统
    
    - 进程的多个线程可以分配到多个处理机上执行

- 线程的属性
  
  - 轻型实体
    
    - ```
      不拥有系统资源
      但每个线程都有唯一的标识符和线程控制块
      ```
  
  - 不同线程可执行相同的程序
  
  - 同一进程各线程共享进程的资源
  
  - 线程是独立调度单位
  
  - 线程被创建后就开始了生命周期

- 线程的状态与转换
  
  - 执行状态
  
  - 就绪状态
  
  - 阻塞状态

- 线程的组织与控制
  
  - 线程控制块TCB
    
    - 线程标识符
    
    - 一组寄存器
    
    - 线程运行状态
    
    - 优先级
    
    - 线程专有存储区
    
    - 堆栈指针
  
  - 线程的创建
    
    - 用户程序启动时通常仅有“初始化线程”在执行，用于创建新线程
  
  - 线程的终止
    
    - 完成任务或出现异常

- 线程的实现方式
  
  - 用户级线程ULT
    
    - 优点
      
      - 线程切换不需要内核空间
      
      - 调度算法进程专用
      
      - 线程实现与操作系统无关，本质是用户程序
    
    - 缺点
      
      - 某线程因系统调用而阻塞时，进程内所有线程都被阻塞
      
      - 不能发挥多处理机优势，内核分配每个进程一个cpu，进程中仅一个线程能执行
  
  - 内核级线程
    
    - 优点
      
      - 多处理机优势，内核同时调度同一进程多线程并行
      
      - 一个线程阻塞其他的还是可以进行
      
      - 内核支持线程数据结构和堆栈小，线程切换快
      
      - 内核本身可采用多线程技术
    
    - 缺点
      
      - 线程切换需要从用户态转到内核态
  
  - 组合方式
    
    - 实现线程库的两种主要办法：
      
      - ```
        用户空间中提供一个无内核支持的库
        所有代码和数据结构都位于用户空间
        ```
      
      - ```
        实现由操作系统支持的内核级的一个库。
        代码和数据结构位于内核空间
        ```
    
    - 三种线程库
      
      - POSIX Pthreads
      
      - Windows API
      
      - Java
        
        - java通常采用宿主系统的线程库实现

- 多线程模型
  
  - 多对一模型
    
    - ```
      多个用户级线程映射到一个内核级线程
      这些用户线程一般属于同一进程
      用户空间完成调度和管理
      ```
    
    - 优点
      
      - 线程管理在用户空间进行
    
    - 缺点
      
      - 若线程访问内核时阻塞，整个进程都阻塞
      
      - 同一时刻只有一个线程能访问内核，多线程不能同时在多处理机上运行
  
  - 一对一模型
    
    - ```
      每个用户级线程映射到一个内核线程
      ```
    
    - 优点
      
      - 线程阻塞允许调度另一个线程，并发度高
    
    - 缺点
      
      - 创建一个用户线程，相应的需要创建一个内核线程
  
  - 多对多模型
    
    - ```
      n个用户线程映射到m个内核级线程上，n>=m
      ```
    
    - 特点
      
      - 克服了多对一模型并发度不高的缺陷
      
      - 克服了一对一模型一个用户进程占用太多内核级线程的缺点
      
      - 拥有上述模型的优点

## 处理机调度

### 调度的概念

- 调度的基本概念
  
  - ```
    对处理机进行分配，
    按照一定算法选择进程
    ```

- 调度的层次
  
  - 高级调度 - 作业调度
    
    - ```
      按照一定原则从外存后备队列中挑选一个或多个
      为他们分配内存、io等必要资源
      并建立相应的进程
      每个作业中只调入调出一次
      ```
    
    - 多道批处理系统大多有该调度，其他系统通常不需要
  
  - 中级调度 - 内存调度
    
    - ```
      目的是提高内存利用率和吞吐量
      将暂时无法运行的进程调至外存 - 挂起态
      当具备运行条件时再重新调入，改为就绪态
      ```
    
    - 存储器管理中的对换功能（swap）
  
  - 低级调度 - 进程调度
    
    - 一般几十毫秒进行一次

- 三级调度的联系
  
  - ```
    作业调度用于建立进程
    进程调度进行处理器分配
    内存调度挂起，提高内存利用率
    ```
  
  - 进程调度是最基本的，不可或缺。

### 调度的目标

不同调度有不同特性，以下为几种评价标准：

- cpu利用率
  
  - $cpu利用率=\frac {cpu有效工作时间}{cpu有效工作时间+cpu空闲等待时间}$

- 系统吞吐量
  
  - 单位时间内cpu完成作业的数量

- 周转时间
  
  - $周转时间= 作业完成时间-作业提交时间$
  
  - $平均周转时间=(所有作业周转时间之和)/n$
  
  - $带权周转时间=\frac {作业周转时间}{作业实际运行时间}$
  
  - $平均带权周转时间=(带权周转时间之和)/n$

- 等待时间
  
  - 进程处于等处理机的时间之和
  
  - 衡量一个调度算法的优劣，常常只需简单地考察等待时间

- 响应时间
  
  - 用户提交请求到系统首次产生响应所用的时间

设计调度，一方面要满足特定系统用户的请求。另一方面要考虑系统整体效率和算法的开销。

### 调度的实现

- 调度程序（调度器）
  
  - 排队器
    
    - ```
      系统中所有就绪进程按照一定策略排成一或多个队列
      ```
  
  - 分派器
    
    - ```
      将调度程序所选的进程从就绪队列取出
      将CPU分配给新进程
      ```
  
  - 上下文切换器
    
    - ```
      处理机进行切换时，会发生两对上下文切换操作：
      第一对：将当前进程上下文保存到pcb中，装入分派程序的上下文呢
      第二对：移出分派程序上下文，将新选进程的菜谱现场信息装入处理机的各个相应寄存器。
      上下文切换需要大量load/store指令
      ```

- 调度的时机、切换与过程
  
  - 现代操作系统不能进行进程的调度与切换的情况
    
    - 处理中断的过程中
    
    - 进程在操作系统内核临界区
    
    - 其他需要完全屏蔽中断的原子操作过程中
  
  - 应当进行进程调度与切换的情况
    
    - 应当引起调度，但不能马上进行调度与切换，应当置系统的请求调度标志。若只有该种情况，则为非剥夺调度
    
    - 中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，如果置请求调度标志则马上进行进程调度与切换。剥夺方式调度。

- 进程调度方式
  
  - 非抢占调度方式（非剥夺方式）
    
    - 优点
      
      - 实现简单
      
      - 系统开销小
      
      - 适用于大多数批处理系统
    
    - 缺点
      
      - 不能用于分时系统和大多数的实时系统
  
  - 抢占调度方式（剥夺方式）
    
    - 优点
      
      - 提高系统吞吐率和相应效率
    
    - 必须遵循一定原则，主要有优先权、短进程优先、时间片原则

- 闲逛进程
  
  - ```
    进程切换时，若没有就绪进程，就调度idle闲逛进程
    闲逛进程优先级最低，不需要cpu之外资源
    ```

- 两种线程的调度
  
  - 用户级线程调度
    
    - 内核不知道线程的存在，选择进程给予时间控制。
  
  - 内核级线程调度
    
    - 选定线程，不考虑是哪个进程，时间片轮转

### 典型的调度算法

- 先来先服务（FCFS）调度算法
  
  - 既可用于作业调度，又可用于进程调度
  
  - 每次选最先来的进程
  
  - 不可剥夺算法
  
  - 优点
    
    - 算法简单
    
    - 长作业有利
    
    - cpu繁忙性作业有利
  
  - 缺点
    
    - 效率低
    
    - 短作业不利（相对sjf和高响应比）
    
    - 不利于io繁忙型

- 短作业优先（SJF）调度算法
  
  - 后备队列中选择一个或若干运行时间最短的
  
  - 缺点
    
    - 长作业不利，甚至会引起饥饿
    
    - 完全未考虑作业紧迫程度
    
    - 长短根据用户提供的估计执行时间而定，不一定能真正实现短作业优先
  
  - SJF调度算法平均等待时间、平均周转时间最少

- 优先级调度算法
  
  - 既可用于作业调度，又可用于进程调度
  
  - 分为
    
    - 非抢占式优先级调度算法
      - 优先级更高的进入就绪队列不会打算 但会到最优先位次
    - 抢占式优先级调度算法
      - 抢占
  
  - 进程优先级
    
    - 静态优先级
    
    - 动态优先级
  
  - 优先级设置原则
    
    - 系统进程 > 用户进程
    
    - 交互型进程 > 非交互型进程
    
    - I/O型进程 > 计算型进程

- 高响应比优先调度算法
  
  - $响应比R_p = \frac {等待时间+要求服务时间}{要求服务时间}$
  
  - 作业调度
  
  - FCFS调度算法和SJF调度算法的综合平衡
  
  - 根据公式
    
    - 作业等待时间相同，服务时间短，响应比高 短作业优先
    
    - 服务时间相同，由等待时间决定，fcfs
    
    - 长作业，响应比可以随着等待时间的增加变高，等待时间足够长就能克服饥饿

- 时间片轮转调度算法
  
  - 分时系统
  
  - 时间片的大小对系统性能的影响很大
  
  - 时间片大->先来先服务
  
  - 时间片小->进程切换频繁
  
  - 时间片长短的影响因素
    
    - 响应时间
    
    -  就绪队列中的进程数量
    
    - 系统处理能力

- 多级队列调度算法
  
  - ```
    设置多个就绪队列
    针对不同需求提供不同调度策略
    不同队列进程的优先级也不同
    多处理机系统可以为每个处理机设置一个单独的就绪队列
    ```

- 多级反馈队列调度算法
  
  - 时间片轮转调度和优先级调度的综合与发展
  
  - ```算法的实现思想
    设置多个就绪队列 不同队列不同优先级
    各个队列进程的运行时间片大小不相同
    每个队列都采用fcfs
    按队列优先级调度
    ```
  
  - 优势
    
    - 终端型作业用户：短作业优先
    
    - 短批处理作业用户：周转时间短
    
    - 长批处理作业用户：不会长期得不到处理

### 进程切换

任何进程都在操作系统的内核支持下运行，与内核密切相关

- 上下文切换
  
  - 切换cpu到另一个进程需要保存当前进程状态并恢复另一个进程的状态
  
  - 上下文：某一时刻cpu寄存器和程序计数器的内容
  
  - 上下文切换流程
    
    - 挂起进程，保存cpu上下文
    
    - 更新pcb信息
    
    - 把进程的pcb移入相应的队列，如就绪阻塞队列
    
    - 选择进程执行，更新pcb
    
    - 跳转到新进程pcb中的程序计数器所指向的位置执行
    
    - 恢复处理机上下文

- 上下文切换的消耗
  
  - 计算密集型
  
  - 如果处理器有多个寄存器组，则只需要改变当前寄存器组的指针

- 上下文切换与模式切换
  
  - 模式切换
    
    - cpu逻辑上可能还在执行同一进程
    
    - 用户态与内核态的切换
  
  - 上下文切换
    
    - 只发生在内核态，多任务操作系统中必需的特性

## 同步与互斥

### 同步与互斥的基本概念

- 临界资源
  
  - 定义：许多资源一次只能被一个进程使用
  
  - 对临界资源的访问
    
    - 进入区
      
      - 一般通过修改正在访问临界区的标志来确认是否阻止其他进程
    
    - 临界区（临界段）
      
      - 访问临界资源的代码
    
    - 退出区
      
      - 清除正在访问临界区的标志
    
    - 剩余区
      
      - 代码中的其余部分

- 同步
  
  - 直接制约关系源于进程间的相互合作
  
  - 需要在某些位置协调工作次序而等待、传递信息所产生的制约关系

- 互斥
  
  - 间接制约关系
    
    - 一个进程进入临界区，另一个进程必须等待
  
  - 为防止多个进程同时进入临界区，同步机制应遵循：
    
    - 空闲让进
    
    - 忙则等待
    
    - 有限等待
      
      - 对于请求访问的进程，有限时间内能够进入临界区
    
    - 让权等待
      
      - 进程不能进入临界区时立即释放处理器，防止进程忙等待

### 实现临界区互斥的基本方法

- 软件实现方法
  
  - 单标志法
    
    - 设置公用变量turn
    
    - 两进程必须交替进入，违反空闲让进
  
  - 双标志法先检查
    
    - 先检查临界资源是否正被访问
    
    - 可能同时进入临界区，违反忙则等待
  
  - 双标志法后检查
    
    - 。。。
  
  - Peterson’s algorithm
